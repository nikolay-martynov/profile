= Fall through a function

Did you know you can omit return statement in C++ code? At least, when using g++. Obviously, Java will not allow the following code to compile:

[source,c++]
----
public class Fall {

    String fall() {
    }

}
----

A pretty straight-forward error message makes it crystal clear what the problem is and where exactly it is:

[source]
----
[user@vm src]$ javac Fall.java
Fall.java:4: error: missing return statement
    }
    ^
1 error
----

However, the following code

[source,c++]
----
#include <string>

class Fall {

    std::string fall() {
    }

};
----

is not an issue for g++:

[source]
----
[user@vm the_wall]$ g++ -c Fall.cpp ; echo $?
0
----

Of course, you wouldn't be doing this intentionally and, of course, you have `-Wall -Wfatal-errors -Wpedantic -pedantic-errors``</code>`` but still it's interesting to see what happens here.

Let's take a more likely example: you have a class with the method that returns something

[source,c++]
----
#ifndef USEFULLTHING_H
#define USEFULLTHING_H

#include <memory>
#include <string>

class UsefullThing {
public:
    UsefullThing();
    UsefullThing(const UsefullThing& orig);
    virtual ~UsefullThing();
    std::auto_ptr<std::string> doUsefullThing();
};

#endif
----

but then you forgot a return statement

[source,c++]
----
#include <iostream>
#include "UsefullThing.h"

UsefullThing::UsefullThing() {
}

UsefullThing::UsefullThing(const UsefullThing& orig) {
}

UsefullThing::~UsefullThing() {
}

std::auto_ptr<std::string> UsefullThing::doUsefullThing() {
    std::cout << "In UsefullThing::doUsefullThing()" << std::endl;
}
----

and now you call this method

[source,c++]
----
#include <iostream>
#include "UsefullThing.h"

int main(int argc, char** argv) {
    UsefullThing thing;
    std::cout << *thing.doUsefullThing() << std::endl;
    return 0;
}
----

and everything seems fine and sunny

[source]
----
[user@vm the_wall]$ g++ -g UsefullThing.cpp main.cpp ; echo $?
0
----

until you run it

[source]
----
[user@vm the_wall]$ ./a.out
In UsefullThing::doUsefullThing()
Segmentation fault (core dumped)
----

Ok. If compiler doesn't help then let's load the core and see where the problem is:

[source]
----
[user@vm the_wall]$ gdb a.out -c core.* -ex bt -ex list -ex "frame 1" -ex quit
[New LWP 5634]
Core was generated by `./a.out'.
Program terminated with signal 11, Segmentation fault.
#0  std::operator<< <char, std::char_traits<char>, std::allocator<char> > (__os=..., __str=...) at /usr/src/debug/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:2758
2758          return __ostream_insert(__os, __str.data(), __str.size());
#0  std::operator<< <char, std::char_traits<char>, std::allocator<char> > (__os=warning: RTTI symbol not found for class 'std::ostream'
..., __str=...) at /usr/src/debug/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:2758
#1  0x0000000000400c5e in main (argc=1, argv=0x7ffc7a20cd88) at main.cpp:6
2753        operator<<(basic_ostream<_CharT, _Traits>& __os,
2754                   const basic_string<_CharT, _Traits, _Alloc>& __str)
2755        {
2756          // _GLIBCXX_RESOLVE_LIB_DEFECTS
2757          // 586. string inserter not a formatted function
2758          return __ostream_insert(__os, __str.data(), __str.size());
2759        }
2760
2761      /**
2762       *  @brief  Read a line from stream into a string.
#1  0x0000000000400c5e in main (argc=1, argv=0x7ffc7a20cd88) at main.cpp:6
6           std::cout << *thing.doUsefullThing() << std::endl;
----

Well... it's quite much more likely that our code is much more buggy than a standard library. It means corruption has happened somewhere earlier. But we don't know exactly where. And since a real code would be much more complex, it would be a nice time spent in a debugger.

However, it's still a question of what actually happens here. Obviously, g++ has generated something and this something is a valid machine code but something has gone wrong. To find precisely what has happened, we can check disassembly:

[source]
----
[user@vm the_wall]$ g++ -g -S UsefullThing.cpp main.cpp ; echo $? ; ls -1 *.s
0
main.s
UsefullThing.s
----

First, let's see what main() is expecting from our method:

[source,x86asm]
----
main:
.LFB1038:
 .file 1 "main.cpp"
 .loc 1 4 0
 .cfi_startproc
 .cfi_personality 0x3,__gxx_personality_v0
 .cfi_lsda 0x3,.LLSDA1038
 pushq %rbp
 .cfi_def_cfa_offset 16
 .cfi_offset 6, -16
 movq %rsp, %rbp
 .cfi_def_cfa_register 6
 pushq %rbx
 subq $56, %rsp
 .cfi_offset 3, -24
 movl %edi, -52(%rbp)
 movq %rsi, -64(%rbp)
----

That's a stack frame setup where our local variables and temporaries are going to live.

[source,x86asm]
----
.LBB2:
 .loc 1 5 0
 leaq -48(%rbp), %rax
 movq %rax, %rdi
.LEHB0:
 call _ZN12UsefullThingC1Ev
----

Here we call the constructor and tell it where the instance is (or will be after initialization). Remember for a moment this offset of 48.

[source,x86asm]
----
.LEHE0:
 .loc 1 6 0
 leaq -32(%rbp), %rax
 leaq -48(%rbp), %rdx
 movq %rdx, %rsi
 movq %rax, %rdi
.LEHB1:
 call _ZN12UsefullThing14doUsefullThingEv
----

Then we call our buggy method and pass two parameters to it. Let me remind the signature:

[source,c++]
----
    std::auto_ptr<std::string> doUsefullThing();
----

So we have exactly zero parameters in C\++ source while g++ generates two hidden parameters. Let's look at them again:

[source,x86asm]
----
 leaq -32(%rbp), %rax
 leaq -48(%rbp), %rdx
 movq %rdx, %rsi
 movq %rax, %rdi
----

* `rsi(48)` is obvious - that's where we have `UsefullThing` instance. Since the method we call is not static, we need to pass `this` and we do it.
* `rdi(32)` is more obscure: there is no single reference to it yet. Let's skip it for a moment and check what happens next.

[source,x86asm]
----
.LEHE1:
 .loc 1 6 0 is_stmt 0 discriminator 1
 leaq -32(%rbp), %rax
 movq %rax, %rdi
 call _ZNKSt8auto_ptrISsEdeEv
----

After demangling, we can see that we call `operator *` on `auto_ptr` here and we pass it a single argument from offset `32`. This must be pointer to `auto_ptr` itself. Now we have an idea that when we have called

[source,c++]
----
    std::auto_ptr<std::string> doUsefullThing();
----

the other hidden parameter was where `auto_ptr` is (or should be after initialization).

[source,x86asm]
----
 movq %rax, %rsi
 movl $_ZSt4cout, %edi
.LEHB2:
 call _ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E
----

Finally, we left-shift result of `operator *` into a stream. And this is where process dies deeper in a library code.


Let's check buggy method assembly to see what exactly misbehavior is:

[source,x86asm]
----
_ZN12UsefullThing14doUsefullThingEv:
.LFB1048:
 .loc 1 13 0
 .cfi_startproc
 pushq %rbp
 .cfi_def_cfa_offset 16
 .cfi_offset 6, -16
 movq %rsp, %rbp
 .cfi_def_cfa_register 6
 subq $16, %rsp
 movq %rdi, -8(%rbp)
 movq %rsi, -16(%rbp)
----

For beginning, we setup our stack frame and save parameters we've got (in case we'll need those registers later, for example, to call another function):

* In `rsi` we had `UsefullThing`. This is our `this`. We store it at offset `16`.
* In `rdi` we had `auto_ptr`. We store it at offset `8`

[source,x86asm]
----
 .loc 1 14 0
 movl $.LC0, %esi
 movl $_ZSt4cout, %edi
 call _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
 movl $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi
 movq %rax, %rdi
 call _ZNSolsEPFRSoS_E
----

This is just two left-shifts. One with a constant string and another with `std::endl`.

[source,x86asm]
----
 .loc 1 15 0
 movq -8(%rbp), %rax
 leave
 .cfi_def_cfa 7, 8
 ret
 .cfi_endproc
----

Well, that's all. We just restore stack and leave returning what we had at offset `8` - `auto_ptr`. The same `auto_ptr` that was passed to us from `main()`.

Ok, now we can tell that `UsefullThing::doUsefullThing()` has been expected to initialize an instance of `auto_ptr` it got as a hidden parameter. But since we did nothing and even omitted return statement, nothing was initialized and method has just returned (in `rax`) the same as what it got on input (however, we know from disassembly of `main()` that `rax` won't be used, instead we were expected to initialize memory passed in `rdi`).

Let's verify it by adding a simple return statement:

[source,c++]
----
    return std::auto_ptr<std::string>();
----

What's changes in assembly is the following:

[source,x86asm]
----
 subq $32, %rsp
 movq %rdi, -24(%rbp)
 movq %rsi, -32(%rbp)
----

We allocate a bit more space now and save `rsi`/`UsefullThing` at `32` and `rdi`/`auto_ptr` at `24`.

[source,x86asm]
----
 .loc 1 15 0
 leaq -16(%rbp), %rax
 movl $0, %esi
 movq %rax, %rdi
 call _ZNSt8auto_ptrISsEC1EPSs
----

Here we call the constructor of `auto_ptr`. One parameter is where instance is and we pass not yet initialized memory from our stack frame. Remember for a moment this offset of `16`. Another parameter is pointer to `std::string` which has `0` as default value.

[source,x86asm]
----
 leaq -16(%rbp), %rax
 movq %rax, %rdi
 call _ZNSt8auto_ptrISsEcvSt12auto_ptr_refIT_EISsEEv
----

This does not demangle but it is a call to operator to cast `auto_ptr` to `auto_ptr_ref` which in turn `release()`-es *temporary* `auto_ptr` at an offset of `16`. Of course, `release()` is needed to avoid `delete` on a memory that still would be used in a moment later.

[source,x86asm]
----
 movq %rax, %rdx
 movq -24(%rbp), %rax
 movq %rdx, %rsi
 movq %rax, %rdi
 call _ZNSt8auto_ptrISsEC1ESt12auto_ptr_refISsE
----

Here we get result of a cast that is `auto_ptr_ref` and call `auto_ptr` constructor that takes it. This time we initialize the instance at an offset of `24` - the one we got in `rdi` when we were called (remind that we're in `std::auto_ptr<std::string> UsefullThing::doUsefullThing()`) and it's the very same `auto_ptr` instance that we should initialize and return to `main()`. Essentially, that's what was missing in a version without `return` statement.

Documentation on the strange constructor explains why all the magic with `auto_ptr_ref`:

[source,c++]
----
      /**
       *  @brief  Automatic conversions
       *
       *  These operations convert an %auto_ptr into and from an auto_ptr_ref
       *  automatically as needed.  This allows constructs such as
       *  @code
       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);
       *    ...
       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);
       *  @endcode
       */
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }
----

[source,x86asm]
----
 leaq -16(%rbp), %rax
 movq %rax, %rdi
 call _ZNSt8auto_ptrISsED1Ev
----

Finally, we call destructor of temporary `auto_ptr` at offset of `16` and leave the function (restoring stack and loading result into `rax`).

Ok, let's recall what happens when we forgot return statement here:

. `main()` has allocated space on stack for instances of `UsefullThing` and `auto_ptr`
. `main()` has passed address of `UsefullThing` to its constructor
. `main()` has passed address of now initialized `UsefullThing` and not yet initialized `auto_ptr` to `UsefullThing::doUsefullThing()`
. `main()` has called `operator*` passing it address of `auto_ptr` that it expected to be initialized now but it actually wasn't
. `operator*` did its job but was actually working on an instance that is a "random" stack content
. `main()` calls left-shift on `std::cout` and passes it result of `operator*` (applied to a "random" data)
. Somewhere deep inside library code we go out of segment bounds or try to write to read-only memory. That's not unexpected because we try to work on result of working on a "random" data which should be even more random and unpredictable.

The summary is that by forgetting a return statement, we've got *uninitialized _hidden_ local variable* which we use until corruption accumulates enough for memory protection to kick-in.

Yes, correct compiler flags can prevent this bug but too many factors sometimes prevent you from using it.
